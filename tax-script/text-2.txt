const puppeteer = require("puppeteer");
const path = require("path");
const fs = require("fs");
const PDFParser = require('pdf-parse');

const dotenv = require('dotenv');
const envPath = path.resolve(__dirname, '../.env');  // path of .env because we can only use environment variables if .env is in the root, so we need to specify it's location
dotenv.config({path: envPath});


const apiKey = process.env.API_KEY;
const baseId = process.env.BASE_ID;
const table = process.env.PROPERTY_APPRAISAL_TAXES_TABLE;

const years = ['2017', '2018', '2019', '2020', '2021', '2022']

const propertyTypes = new Set();
propertyTypes.add('single family');
propertyTypes.add('condominium');
propertyTypes.add('multi family');
propertyTypes.add('commercial');
propertyTypes.add('industrial');
propertyTypes.add('agriculture');
propertyTypes.add('vacant land');
propertyTypes.add('institutional');
propertyTypes.add('governmental');
propertyTypes.add('other properties');
propertyTypes.add('real estate parcels');
propertyTypes.add('pers prop & cent assd');
propertyTypes.add('all assessed property');


const correctType = (text) => {
    let correctType = "";
    const lowerText = text.toLowerCase();

    for (const propertyType of propertyTypes) {
        if (propertyType.includes(lowerText) /*&& isNaN(text) && text.length >= 3*/) {

            // replaces the text with the full property type
            correctType = propertyType.toUpperCase();
            break; // leave out of the loop once a match is found
        }
    }

    return correctType;
}


const readPDF = async (path, year) => {

    // const pdfPath = path;
    const pdfPath = __dirname + '/downloads/2017.pdf';

    // read the pdf file
    const pdf = fs.readFileSync(pdfPath);

    // parse the pdf
    const data = await PDFParser(pdf);

    const lines = data.text.split('\n');

    const splitLinesByDoubleSpace = lines.map(line => line.split("  ").map(text => text.trim()));


    let cleanedText = "";

    for(let x = 0; x < splitLinesByDoubleSpace.length; x++){

        for(let y = 0; y < splitLinesByDoubleSpace[x].length; y++){

            let text = splitLinesByDoubleSpace[x][y];
            if( text === '' || ( isNaN(parseInt(text)) && text.length === 1 ) ){
                continue;
            }

            let correctPropertyType = correctType(text.trim());
            cleanedText += ( correctPropertyType === '' ? text : correctPropertyType ) + '\n';
        }
    }

    fs.writeFileSync(__dirname + '/text.txt', cleanedText);

    let canReadSection = false;
    let propertyTypeValues = [];

    const cleanedTextLines = cleanedText.split("\n");

    for(let x = 0; x < cleanedTextLines.length; x++){

        const line = cleanedTextLines[x];

        if (line.toLowerCase().includes(`2017 Miami-Dade County Preliminary Assessment Roll`.toLowerCase())) {
            console.log(line);
            canReadSection = true;
            x += 11; // this immediately jumps us the the single family section
            continue; // skips to the next iteration
        }

        if (canReadSection) {

            if (propertyTypes.has(line.toLowerCase())) {


                while( propertyTypes.has(cleanedTextLines[x+1]) ){

                    // propertyTypeValues.push(cleanedTextLines[x+1]);
                    console.log(cleanedTextLines[x+1]);
                    x++;
                }

                if( propertyTypeValues.length > 8 ){ // sometimes the real estate values at index 1 and 2 get cut off and we have to handle that
                    mergeIndices(propertyTypeValues);
                }
                // console.log(propertyTypeValues);
                // console.log(line);

                // await sendToAirTable(propertyTypeValues, 2017, line)

                propertyTypeValues = []; // reset the array

                // check if the next property type is any of these
                if (
                    line.toLowerCase().includes("all assessed property") ||
                    line.toLowerCase().includes("pers prop & cent assd")
                ) {
                    propertyTypeValues.push('0'); // this is for count since the space for count is stripped when doing split.('\n')
                }

                continue;
            }

            const removedCommas = line.split(',').join('');
            if (
                (Number.isInteger(parseInt(removedCommas)) || // is a valid number
                    line.includes('%')) && // is a percentage
                !line.toLowerCase().includes(`2016 PRELIMINARY VALUES`.toLowerCase()) // don't not reach the end of the page
            ) {
                propertyTypeValues.push(line);
            }


            if (line.toLowerCase().includes(`2016 PRELIMINARY VALUES`.toLowerCase())) {
                canReadSection = false;
                // console.log(propertyTypeValues);
                // console.log(canReadSection);
            }
        }
    }


}

const mergeIndices = (array) => {
    if (array.length === 9) {

        const num1 = array[1]/*.split(',').join('')*/;
        const num2 = array[2]/*.split(',').join('')*/;

        const mergedValue = (num1 + num2).toLocaleString();

        // remove elements at indices 1 and 2
        array.splice(1, 2);

        // insert the merged value at index 1
        array.splice(1, 0, mergedValue);
    }
}



// stores each row into the airtable
const createRecord = async (recordData) => {

    const airtableURL = `https://api.airtable.com/v0/${baseId}/${table}`;

    try {
        const response = await fetch(airtableURL, {
            method: 'POST',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(recordData)
        });


        if (response.ok) {

            // console.log('RECORD CREATED'/*, data*/)
        } else {
            console.error('Failed to create record:', response.statusText);
        }
    } catch (error) {
        console.error('Error:', error);
    }
};

const updateRecord = async (recordData, id) => {

    const airtableURL = `https://api.airtable.com/v0/${baseId}/${table}/${id}`;


    try {
        const response = await fetch(airtableURL, {
            method: 'PATCH',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json',
            },
            body: JSON.stringify(recordData)
        });

        if (response.ok) {

            console.log('RECORD UPDATED'/*, data*/)
        } else {
            console.error('Failed to create record:', response.statusText);
        }
    } catch (error) {
        console.error('Error:', error);
    }
};

const getRecord = async (year, propertyType) => {


    // THIS IS VERY IMPORTANT IT HELPS TO ENCODE SPECIAL CHARCATERS SUCH AS &
    // HAD AN ISSUE WHERE IT KEPT THROWING AN EXCEPTION BECUASE OF 'PERS PROP & CENT ASSD'
    // AIR TABLE KEPT SAYING IT COULD NOT BE FOUND
    const encodedPropertyType = encodeURIComponent(propertyType);

    const airtableURL = `https://api.airtable.com/v0/${baseId}/${table}?filterByFormula=AND({Year} = ${year}, {Property Type} = "${encodedPropertyType}")`;

    try {
        const response = await fetch(airtableURL, {
            method: 'GET',
            headers: {
                'Authorization': `Bearer ${apiKey}`,
                'Content-Type': 'application/json',
            }
        });

        const data = await response.json();
        return data;

    } catch (error) {
        console.error('Error:', error);
    }
}


const sendToAirTable = async (propertyTypeValues, year, line)=>{

    console.log(line + ": ", propertyTypeValues);

    return;
    // update or insert in airtable
    const record = await getRecord(year, line.toUpperCase());

    const propertyType = line.toUpperCase();
    const count = propertyTypeValues[0];
    const justValue = propertyTypeValues[3];
    const taxableValue = propertyTypeValues[4];
    const taxableValueDiff = propertyTypeValues[5];
    const pct = propertyTypeValues[6];
    const newCons = propertyTypeValues[7];

    // the record exists
    if( record.records?.length > 0 ){

        recordData = {
            "fields": {
                // "Property Type": propertyType,
                // "Year": parseInt(year),
                "Count": parseInt(count),
                "Just Value": justValue,
                "Taxable Value": taxableValue,
                "Taxable Value Diff": taxableValueDiff,
                "Pct": pct,
                "New Cons": parseInt(newCons),
            }
        };

        const id = record.records[0].id;
        await updateRecord(recordData, id);

        // if record does not exist
    }else{

        recordData = {
            "records": [
                {
                    "fields": {
                        "Property Type": propertyType,
                        "Year": parseInt(year),
                        "Count": parseInt(count),
                        "Just Value": justValue,
                        "Taxable Value": taxableValue,
                        "Taxable Value Diff": taxableValueDiff,
                        "Pct": pct,
                        "New Cons": parseInt(newCons),
                    }
                }
            ]
        };

        await createRecord(recordData);
    }

}

readPDF();

